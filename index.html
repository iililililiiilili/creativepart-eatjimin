<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>밥먹자! 안지민</title>
  <style>
    body {
      background-color: #f0f0f0;
      margin: 0;
      padding: 20px;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 12px;
    }
    #subtitle, #score {
      text-align: center;
      font-weight: bold;
    }
    #subtitle {
      font-size: 20px;
    }
    #score {
      font-size: 40px;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <p id="subtitle">밥먹자! 안지민</p>
  <p id="score">현재점수: 0</p>
  <main><canvas id="canvas"></canvas></main>

  <script>
    const CANVAS_WIDTH = 800, CANVAS_HEIGHT = 500;
    const RUNNER_WIDTH = 100, RUNNER_HEIGHT = 100;
    const RUNNER_START_X = 10, RUNNER_START_Y = 400;
    const JUMP_SPEED = 6, MAX_JUMP_HEIGHT = 20;
    const OBSTACLE_SPEED_BASE = 4, OBSTACLE_FREQUENCY_BASE = 90;
    const SCORE_PER_OBSTACLE = 10;
    const VILLAIN_WIDTH = 150 * 2, VILLAIN_HEIGHT = 200 * 1.5;

    const ASSETS = {
      backgroundTitle: './background/title.png',
      startBtn: './background/gamestart.png',
      gameOver: './background/gameover.png',
      restart: './background/restart.png',
      gameComplete: './background/gamecomplete.png',
      gameOverBackground: './background/gameover_background.png',
      runnerSit: './character/jimin-sit.png',
      runnerFly: './character/jimin-fly.png',
      runnerCrash: './character/jimin-crash.png',
      backgrounds: [
        './background/samin-background.png',
        './background/sohyun-background.png',
        './background/doyun-background.png',
        './background/yeonki-background.png',
        './background/sangwoo-background.png',
        './background/boss-background.png'
      ],
      villains: [
        './character/samin-basic.png',
        './character/sohyun-basic.png',
        './character/doyun-basic.png',
        './character/yeonki-basic.png',
        './character/sangwoo-basic.png',
        './character/boss-basic.png'
      ],
      obstacles: [
        './character/samin-obstacle.png',
        './character/sohyun-obstacle.png',
        './character/doyun-obstacle.png',
        './character/yeonki-obstacle.png',
        './character/sangwoo-obstacle.png'
      ]
    };

    window.onload = () => {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = CANVAS_WIDTH;
      canvas.height = CANVAS_HEIGHT;

      const scoreText = document.getElementById('score');
      let images = {};
      let loaded = 0;
      let total = 11 + ASSETS.backgrounds.length + ASSETS.villains.length + ASSETS.obstacles.length;

      let gameStarted = false, gameOver = false, gameCleared = false, finalTransition = false;
      let score = 0, timer = 0;
      let jump = false;
      let runnerY = RUNNER_START_Y;
      let currentStage = 0;
      let villainY = CANVAS_HEIGHT;
      let villainReady = false;
      let obstacleSpeed = OBSTACLE_SPEED_BASE;
      let obstacleFrequency = OBSTACLE_FREQUENCY_BASE;
      let villainExplode = false, explosionTimer = 0;

      const runner = {
        x: RUNNER_START_X,
        y: RUNNER_START_Y,
        width: RUNNER_WIDTH,
        height: RUNNER_HEIGHT
      };

      class Obstacle {
        constructor(image) {
          this.x = CANVAS_WIDTH;
          this.y = Math.random() * (CANVAS_HEIGHT - 80) + 30;
          this.width = 50;
          this.height = 50;
          this.image = image;
          this.frame = 0;
        }
        draw(wave = false) {
          if (wave) this.y += Math.sin(this.frame++ / 5) * 2;
          ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
        }
      }

      const obstacles = [];

      const loadImage = (name, src) => {
        const img = new Image();
        img.src = src;
        img.onload = () => {
          images[name] = img;
          loaded++;
          if (loaded === total) drawStartScreen();
        };
      };

      // 이미지 로딩
      loadImage('title', ASSETS.backgroundTitle);
      loadImage('startBtn', ASSETS.startBtn);
      loadImage('gameOver', ASSETS.gameOver);
      loadImage('restart', ASSETS.restart);
      loadImage('gameComplete', ASSETS.gameComplete);
      loadImage('gameOverBackground', ASSETS.gameOverBackground);
      loadImage('runnerSit', ASSETS.runnerSit);
      loadImage('runnerFly', ASSETS.runnerFly);
      loadImage('runnerCrash', ASSETS.runnerCrash);
      ASSETS.backgrounds.forEach((src, i) => loadImage(`bg${i}`, src));
      ASSETS.villains.forEach((src, i) => loadImage(`villain${i}`, src));
      ASSETS.obstacles.forEach((src, i) => loadImage(`obstacle${i}`, src));

      function drawStartScreen() {
        ctx.drawImage(images.title, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.drawImage(images.startBtn, (CANVAS_WIDTH - 200) / 2, (CANVAS_HEIGHT + 100) / 2, 200, 100);
      }

      function drawGameOverScreen() {
        ctx.drawImage(images.gameOverBackground, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.drawImage(images.restart, (CANVAS_WIDTH - 100) / 2, (CANVAS_HEIGHT + 50) / 2, 100, 50);
      }

      function isCollision(a, b) {
        return !(a.x > b.x + b.width || a.x + a.width < b.x || a.y > b.y + b.height || a.y + a.height < b.y);
      }

      function animate() {
        if (gameOver && !gameCleared) {
          drawGameOverScreen();
          return;
        }

        requestAnimationFrame(animate);
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        const stage = Math.min(Math.floor(score / 200), 5);
        if (stage !== currentStage && !gameCleared) {
          currentStage = stage;
          villainY = CANVAS_HEIGHT;
          villainReady = false;
          obstacleSpeed = OBSTACLE_SPEED_BASE + stage;
          obstacleFrequency = Math.max(20, OBSTACLE_FREQUENCY_BASE - stage * 10);
        }

        ctx.drawImage(images[`bg${currentStage}`], 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        if (!villainReady && !villainExplode) {
          villainY -= 5;
          if (villainY <= CANVAS_HEIGHT - VILLAIN_HEIGHT) {
            villainY = CANVAS_HEIGHT - VILLAIN_HEIGHT;
            villainReady = true;
          }
        }

        if (!villainExplode) {
          ctx.drawImage(images[`villain${currentStage}`], CANVAS_WIDTH - VILLAIN_WIDTH, villainY, VILLAIN_WIDTH, VILLAIN_HEIGHT);
        }

        if (score >= 1200 && !gameCleared) {
          gameCleared = true;
          villainExplode = true;
          explosionTimer = 60;
        }

        if (villainExplode) {
          explosionTimer--;
          if (explosionTimer <= 0) villainExplode = false;
        }

        if (!gameCleared && villainReady && timer % obstacleFrequency === 0) {
          if (currentStage < 5) {
            obstacles.push(new Obstacle(images[`obstacle${currentStage}`]));
          } else {
            for (let i = 0; i < 2; i++) {
              const img = images[`obstacle${Math.floor(Math.random() * 5)}`];
              obstacles.push(new Obstacle(img));
            }
          }
        }

        obstacles.forEach((obs, i) => {
          obs.x -= obstacleSpeed;
          obs.draw(currentStage === 5);
          if (!gameCleared && isCollision(runner, obs)) gameOver = true;
          if (obs.x + obs.width < 0) {
            obstacles.splice(i, 1);
            score += SCORE_PER_OBSTACLE;
            scoreText.textContent = '현재점수: ' + score;
          }
        });

        // 점프
        if (jump && runner.y > MAX_JUMP_HEIGHT) {
          runner.y -= JUMP_SPEED;
        } else if (!jump && runner.y < RUNNER_START_Y) {
          runner.y += JUMP_SPEED;
        }

        if (runner.y < MAX_JUMP_HEIGHT) runner.y = MAX_JUMP_HEIGHT;
        if (runner.y > RUNNER_START_Y) runner.y = RUNNER_START_Y;

        let runnerImage = images.runnerSit;
        if (gameCleared) {
          runner.y -= 3;
          runnerImage = images.runnerFly;
          if (runner.y < -RUNNER_HEIGHT) finalTransition = true;
        } else {
          runnerImage = gameOver ? images.runnerCrash : (jump || runner.y < RUNNER_START_Y) ? images.runnerFly : images.runnerSit;
        }

        ctx.drawImage(runnerImage, runner.x, runner.y, runner.width, runner.height);

        if (gameCleared) {
          ctx.drawImage(images.gameComplete, (CANVAS_WIDTH - 400) / 2, (CANVAS_HEIGHT - 200) / 2, 400, 200);
        }

        if (finalTransition) {
          drawGameOverScreen();
        }

        timer++;
      }

      canvas.addEventListener('click', e => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;

        if (!gameStarted) {
          const btnX = (CANVAS_WIDTH - 200) / 2, btnY = (CANVAS_HEIGHT + 100) / 2;
          if (x >= btnX && x <= btnX + 200 && y >= btnY && y <= btnY + 100) {
            gameStarted = true;
            animate();
          }
        } else if ((gameOver || finalTransition) && x >= (CANVAS_WIDTH - 100) / 2 && x <= (CANVAS_WIDTH + 100) / 2 &&
          y >= (CANVAS_HEIGHT + 50) / 2 && y <= (CANVAS_HEIGHT + 100) / 2) {
          location.reload();
        }
      });

      document.addEventListener('keydown', e => { if (e.code === 'Space') jump = true; });
      document.addEventListener('keyup', e => { if (e.code === 'Space') jump = false; });
    };
  </script>
</body>
</html>
